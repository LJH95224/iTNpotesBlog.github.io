(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{484:function(t,a,n){"use strict";n.r(a);var e=n(42),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_3-字符串的扩展"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-字符串的扩展"}},[t._v("#")]),t._v(" 3. 字符串的扩展")]),t._v(" "),n("blockquote",[n("ol",[n("li",[t._v("字符的 Unicode 表示法")]),t._v(" "),n("li",[t._v("codePointAt()")]),t._v(" "),n("li",[t._v("String.fromCodePoint()")]),t._v(" "),n("li",[t._v("字符串的遍历接口")]),t._v(" "),n("li",[t._v("normalize()")]),t._v(" "),n("li",[t._v("includes(),  startsWidth(), endsWidth()")]),t._v(" "),n("li",[t._v("repeat()")]),t._v(" "),n("li",[t._v("padStart(), padEnd()")]),t._v(" "),n("li",[t._v("matchAll()")]),t._v(" "),n("li",[t._v("模板字符串()")]),t._v(" "),n("li",[t._v("实例： 模板编译()")]),t._v(" "),n("li",[t._v("标签模板()")]),t._v(" "),n("li",[t._v("String.raw()")]),t._v(" "),n("li",[t._v("模板字符串的限制()")])])]),t._v(" "),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_1-字符的-unicode-表示法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-字符的-unicode-表示法"}},[t._v("#")]),t._v(" 1. 字符的 Unicode 表示法")]),t._v(" "),n("p",[t._v("JavaScript 允许采用 "),n("strong",[t._v("\\uxxxx")]),t._v(" 形式表示一个字符，其中 "),n("strong",[t._v("xxxx")]),t._v(" 表示字符的 Unicode 码点")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('"\\u0061"\n// "a"\n')])])]),n("p",[t._v("但是，这种表示法只限于码点在 "),n("strong",[t._v("\\u0000")]),t._v(" ~ "),n("strong",[t._v("\\uFFFF")]),t._v(" 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('"\\uD842\\uDFB7"\n// "𠮷"\n\n"\\u20BB7"\n// " 7"  （注意7前面有空格）\n')])])]),n("p",[t._v("上面代码表示，如果直接在 "),n("strong",[t._v("\\u")]),t._v(" 后面跟上超过 "),n("strong",[t._v("0xFFFF")]),t._v(" 的数值（比如 "),n("strong",[t._v("\\u20BB7")]),t._v(" ）,JavaScript会理解成 "),n("strong",[t._v("\\u20BB+7")]),t._v("。由于 "),n("strong",[t._v("\\u20BB")]),t._v(" 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 "),n("strong",[t._v("7")]),t._v("。")]),t._v(" "),n("p",[t._v("ES6 对着一点做出了改进，只要将码点放入大括号，就能正确解读该字符。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('"\\u{20BB7}"\n// "𠮷"\n\n"\\u{41}\\u{42}\\u{43}"\n// "ABC"\n\nlet hello = 123;\nhell\\u{6F} // 123\n\n\'\\u{1F680}\' === \'\\uD83D\\uDE80\'\n// true\n')])])]),n("p",[t._v("上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。\n有了这种表示法之后，JavaScript 共有6中方法表示一个字符。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n")])])]),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_2-codepointat"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-codepointat"}},[t._v("#")]),t._v(" 2. codePointAt()")]),t._v(" "),n("p",[t._v("JavaScript 内部， 字符以 UTF-16 的格式储存，每个字符固定为 "),n("strong",[t._v("2")]),t._v(" 个字节。对于那些需要 "),n("strong",[t._v("4")]),t._v(" 个字节储存的字符 （Unicode 码点大于 "),n("strong",[t._v("0xFFFF")]),t._v(" 的字符），JavaScript会被认为它们是两个字符")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var s = \"𠮷\";\n\ns.length // 2\ns.charAt(0) // ''\ns.charAt(1) // ''\ns.charCodeAt(0) // 55362\ns.charCodeAt(1) // 57271\n")])])]),n("p",[t._v("上面代码中，汉子“𠮷” （注意，这个字不是“吉祥”的“𠮷”）的码点是 "),n("strong",[t._v("0x20BB7")]),t._v(", UTF-16 编码为 "),n("strong",[t._v("0xD842 0xDFB7")]),t._v(" (十进制为 "),n("strong",[t._v("55362  57271")]),t._v("), 需要 "),n("strong",[t._v("4")]),t._v(" 个字节储存。对于这种 "),n("strong",[t._v("4")]),t._v(" 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 "),n("strong",[t._v("2")]),t._v("， 而且 "),n("strong",[t._v("chartAt")]),t._v(" 方法无法读取整个字符， "),n("strong",[t._v("chartCodeAt")]),t._v(" 方法只能分别返回前两个字节和后两个字节的值。")]),t._v(" "),n("p",[t._v("ES6 提供了 "),n("strong",[t._v("codePointAt")]),t._v(" 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let s = '𠮷a';\n\ns.codePointAt(0) // 134071\ns.codePointAt(1) // 57271\n\ns.codePointAt(2) // 97\n")])])]),n("p",[n("strong",[t._v("codePointAt")]),t._v(" 方法的参数，是字符在字符串中的位置（从0开始）。上面代码中， JavaScript将 “𠮷a” 视为三个字符，codePointAt 方法在第一个字符上，正确地识别了 “𠮷”， 返回了他的十进制码点 134071 （即十六进制的 "),n("strong",[t._v("20BB7")]),t._v("）。在第二个字符（即“𠮷”的后面两个字节） 和第三个字符 ‘a’ 上，"),n("strong",[t._v("codePointAt")]),t._v(" 方法的结果与 "),n("strong",[t._v("chartCodeAt")]),t._v(" 方法相同。")]),t._v(" "),n("p",[t._v("总之，"),n("strong",[t._v("codePointAt")]),t._v("，方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 "),n("strong",[t._v("charCodeAt")]),t._v(" 方法相同。")]),t._v(" "),n("p",[n("strong",[t._v("codePointAt")]),t._v(" 方法返回的是码点的十进制值，如果想要16进制的值，你可以使用 "),n("strong",[t._v("toString")]),t._v(" 方法转换一下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let s = \'𠮷a\';\n\ns.codePointAt(0).toString(16) // "20bb7"\ns.codePointAt(2).toString(16) // "61"\n')])])]),n("p",[t._v("你可能注意到了，"),n("strong",[t._v("codePointAt")]),t._v(" 方法的参数，仍然是不正确的。比如，上面代码中，字符 "),n("strong",[t._v("a")]),t._v(" 在字符串 "),n("strong",[t._v("s")]),t._v(" 的正确位置序号应该是 1，但是必须向 "),n("strong",[t._v("codePointAt")]),t._v(" 方法传入 2。解决这个问题的一个办法是使用 "),n("strong",[t._v("for...of")]),t._v(" 循环，因为它会正确识别 32 位的 UTF-16 字符。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let s = '𠮷a';\nfor (let ch of s) {\n  console.log(ch.codePointAt(0).toString(16));\n}\n// 20bb7\n// 61\n")])])]),n("p",[n("strong",[t._v("codePointAt")]),t._v(" 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n\nis32Bit("𠮷") // true\nis32Bit("a") // false\n')])])]),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_3-string-fromcodepoint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-string-fromcodepoint"}},[t._v("#")]),t._v(" 3. String.fromCodePoint()")]),t._v(" "),n("p",[t._v("ES5 提供 "),n("strong",[t._v("String.fromCharCode")]),t._v(" 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 "),n("strong",[t._v("0xFFFF")]),t._v("）。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('String.fromCharCode(0x20BB7)\n// "ஷ"\n')])])]),n("p",[t._v("上面代码中 "),n("strong",[t._v("，String.fromCharCode")]),t._v(" 不能识别大于 __0xFFFF__的码点，所以 "),n("strong",[t._v("0x20BB7")]),t._v(" 就发生了溢出，最高位 "),n("strong",[t._v("2")]),t._v(" 被舍弃了，最后返回码点 "),n("strong",[t._v("U+0BB7")]),t._v(" 对应的字符，而不是码点 "),n("strong",[t._v("U+20BB7")]),t._v(" 对应的字符。")]),t._v(" "),n("p",[t._v("ES6 提供了 "),n("strong",[t._v("String.fromCodePoint")]),t._v(" 方法，可以识别大于 "),n("strong",[t._v("0xFFFF")]),t._v(" 的字符，弥补了 "),n("strong",[t._v("String.fromCharCode")]),t._v(" 方法的不足。在作用上，正好与 "),n("strong",[t._v("codePointAt")]),t._v(" 方法相反。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("String.fromCodePoint(0x20BB7)\n// \"𠮷\"\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'\n// true\n")])])]),n("p",[t._v("上面代码中，如果 "),n("strong",[t._v("String.fromCodePoint")]),t._v(" 方法有多个参数，则它们会被合并成一个字符串返回。")]),t._v(" "),n("p",[t._v("注意，"),n("strong",[t._v("fromCodePoint")]),t._v(" 方法定义在 "),n("strong",[t._v("String")]),t._v(" 对象上，而 "),n("strong",[t._v("codePointAt")]),t._v(" 方法定义在字符串的实例对象上。")]),t._v(" "),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_4-字符串的遍历接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-字符串的遍历接口"}},[t._v("#")]),t._v(" 4. 字符串的遍历接口")]),t._v(" "),n("p",[t._v("ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 "),n("strong",[t._v("for...of")]),t._v(" 循环遍历。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('for (let codePoint of \'foo\') {\n  console.log(codePoint)\n}\n// "f"\n// "o"\n// "o"\n')])])]),n("p",[t._v("除了遍历字符串，这个遍历器最大的优点是可以识别大于 "),n("strong",[t._v("0xFFFF")]),t._v(" 的码点。传统的 "),n("strong",[t._v("for")]),t._v(" 循环无法识别这样的码点")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let text = String.fromCodePoint(0x20BB7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);\n}\n// " "\n// " "\n\nfor (let i of text) {\n  console.log(i);\n}\n// "𠮷"\n')])])]),n("p",[t._v("上面代码中，字符串 "),n("strong",[t._v("text")]),t._v(" 只有一个字符，但是 "),n("strong",[t._v("for")]),t._v(" 循环会认为它包含两个字符（都不可打印），而 "),n("strong",[t._v("for...of")]),t._v(" 循环会正确识别出这一个字符。")]),t._v(" "),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_5-normalize"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-normalize"}},[t._v("#")]),t._v(" 5. normalize()")]),t._v(" "),n("p",[t._v("许多欧洲语言都有语调符号和重音符号，为了表示他们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符比如 "),n("strong",[t._v("Ǒ")]),t._v("（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如 "),n("strong",[t._v("O")]),t._v("（\\u004F）和 "),n("strong",[t._v("ˇ")]),t._v("（\\u030C）合成 "),n("strong",[t._v("Ǒ")]),t._v("（\\u004F\\u030C）。")]),t._v(" "),n("p",[t._v("这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'\\u01D1'==='\\u004F\\u030C' //false\n\n'\\u01D1'.length // 1\n'\\u004F\\u030C'.length // 2\n")])])]),n("p",[t._v("上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。")]),t._v(" "),n("p",[t._v("ES6 提供字符串实例的 "),n("strong",[t._v("normalize()")]),t._v(" 方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()\n// true\n")])])]),n("p",[n("strong",[t._v("normalize")]),t._v(" 方法可以接受一个参数来指定 "),n("strong",[t._v("normalize")]),t._v(" 的方式，参数的四个可选值如下：")]),t._v(" "),n("ul",[n("li",[n("strong",[n("strong",[t._v("NFC")])]),t._v("， 默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。")]),t._v(" "),n("li",[n("strong",[n("strong",[t._v("NFD")])]),t._v("， 表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。")]),t._v(" "),n("li",[n("strong",[n("strong",[t._v("NFKC")])]),t._v("， 表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）")]),t._v(" "),n("li",[n("strong",[n("strong",[t._v("NFKD")])]),t._v(", 表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'\\u004F\\u030C'.normalize('NFC').length // 1\n'\\u004F\\u030C'.normalize('NFD').length // 2\n")])])]),n("p",[t._v("上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。")]),t._v(" "),n("p",[t._v("不过，"),n("strong",[t._v("normalize")]),t._v(" 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。")]),t._v(" "),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_6-includes-startswidth-endswidth"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-includes-startswidth-endswidth"}},[t._v("#")]),t._v(" 6. includes(), startsWidth(), endsWidth()")]),t._v(" "),n("p",[t._v("传统上， JavaScript只有 "),n("strong",[t._v("indexOf")]),t._v(" 方法，可以用来确定一个字符串是否包含在另一个字符串中。 ES6又提供了三种新方法。")]),t._v(" "),n("blockquote",[n("ul",[n("li",[n("strong",[t._v("includes()")]),t._v(": 返回布尔值，表示是否找到了参数字符串。")]),t._v(" "),n("li",[n("strong",[t._v("startsWidth()")]),t._v(": 返回布尔值，表示参数字符串是否在原字符串的头部。")]),t._v(" "),n("li",[n("strong",[t._v("endsWidth()")]),t._v(": 返回布尔值，表示参数字符串是否在原字符串的尾部。")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n")])])]),n("p",[t._v("这三个方法都支持第二个参数，表示开始搜索的位置")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n")])])]),n("p",[t._v("上面代码表示，使用第二个参数 "),n("strong",[t._v("n")]),t._v(" 时，"),n("strong",[t._v("endsWidth")]),t._v(" 的行为与其他两个方法有所不同。它针对前 "),n("strong",[t._v("n")]),t._v(" 个字符，而其他两个方法针对从第 "),n("strong",[t._v("n")]),t._v(" 个位置知道字符串结束。")]),t._v(" "),n("h2",{attrs:{id:"_7-repeat"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-repeat"}},[t._v("#")]),t._v(" 7. repeat()")]),t._v(" "),n("p",[n("strong",[t._v("repeat")]),t._v(" 方法返回一个新字符串，表示将原字符串重复 "),n("strong",[t._v("n")]),t._v(" 次。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n")])])]),n("br"),t._v("\n参数如果是小数，会被取整\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'na'.repeat(2.9) // \"nana\"\n")])])]),n("br"),t._v(" "),n("p",[t._v("如果 "),n("strong",[t._v("repeat")]),t._v(" 的参数是负数或者 "),n("strong",[t._v("Infinity")]),t._v(" ，会报错。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n")])])]),n("br"),t._v("\n但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于 __-0__ ，__repeat__ 视同为 0。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'na'.repeat(-0.9) // \"\"\n")])])]),n("br"),t._v(" "),n("p",[t._v("参数NaN等同于 0。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'na'.repeat(NaN) // \"\"\n")])])]),n("br"),t._v("\n如果 __repeat__ 的参数是字符串，则会先转换成数字。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n")])])]),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_8-padstart-padend"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-padstart-padend"}},[t._v("#")]),t._v(" 8. padStart, padEnd()")]),t._v(" "),n("p",[t._v("ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。"),n("strong",[t._v("padStart()")]),t._v(" 用于头部补全， "),n("strong",[t._v("padEnd()")]),t._v(" 用于尾部补全。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n")])])]),n("p",[t._v("上面代码中，"),n("strong",[t._v("padStart")]),t._v("  和 __padEnd__一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。\n"),n("br")]),t._v(" "),n("p",[t._v("如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'xxx'.padStart(2, 'ab') // 'xxx'\n'xxx'.padEnd(2, 'ab') // 'xxx'\n")])])]),n("br"),t._v(" "),n("p",[t._v("如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'abc'.padStart(10, '0123456789')\n// '0123456abc'\n")])])]),n("br"),t._v(" "),n("p",[t._v("如果省略第二个参数，默认使用空格补全长度。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'x'.padStart(4) // '   x'\n'x'.padEnd(4) // 'x   '\n")])])]),n("br"),t._v(" "),n("p",[n("strong",[t._v("padStart")]),t._v(" 的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'1'.padStart(10, '0') // \"0000000001\"\n'12'.padStart(10, '0') // \"0000000012\"\n'123456'.padStart(10, '0') // \"0000123456\"\n")])])]),n("br"),t._v(" "),n("p",[t._v("另一个用途是提示字符串格式。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"\n'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"\n")])])]),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_9-matchall"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-matchall"}},[t._v("#")]),t._v(" 9. matchAll()")]),t._v(" "),n("p",[t._v("__matchAll__方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。")]),t._v(" "),n("h2",{attrs:{id:"_10-模板字符串"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-模板字符串"}},[t._v("#")]),t._v(" 10. 模板字符串")]),t._v(" "),n("p",[t._v("传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("$('#result').append(\n  'There are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onSale +\n  '</em> are on sale!'\n);\n")])])]),n("p",[t._v("上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("$('#result').append(`\n  There are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onSale}</em>\n  are on sale!\n`);\n")])])]),n("p",[t._v("模板字符串（template string）是增强版的字符串，用反引号（`）标识。他可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 普通字符串\n`In JavaScript \'\\n\' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nlet name = "Bob", time = "today";\n`Hello ${name}, how are you ${time}?`\n')])])]),n("p",[t._v("上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let greeting = `\\`Yo\\` World!`;\n")])])]),n("p",[t._v("如果使用模板字符串标识多行字符串，所有的空格和缩进都会被保留在输出之中。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n")])])]),n("p",[t._v("上面代码中，所有模板字符串的空格和换行，都是被保留的，比如 "),n("strong",[n("ul")]),t._v(" 标签前面会有一个换行。如果你不想要这个换行，可以使用 "),n("strong",[t._v("trim")]),t._v(" 方法消除它。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n")])])]),n("p",[t._v("模板字符串中嵌入变量，需要将变量名写在${}之中。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function authorize(user, action) {\n  if (!user.hasPrivilege(action)) {\n    throw new Error(\n      // 传统写法为\n      // 'User '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `User ${user.name} is not authorized to do ${action}.`);\n  }\n}\n")])])]),n("br"),t._v("\n大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// "1 + 2 = 3"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// "1 + 4 = 5"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// "3"\n')])])]),n("br"),t._v("\n模板字符串之中还能调用函数。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function fn() {\n    return 'hello world';\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n")])])]),n("p",[t._v("如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 "),n("strong",[t._v("toString")]),t._v(" 方法。")]),t._v(" "),n("br"),t._v("\n如果模板字符串中的变量没有声明，将报错。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 变量place没有声明\nlet msg = `Hello, ${place}`;\n// 报错\n")])])]),n("br"),t._v("\n由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("`Hello ${'World'}`\n// \"Hello World\"\n")])])]),n("br"),t._v("\n模板字符串甚至还能嵌套\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n")])])]),n("p",[t._v("上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const data = [\n    { first: '<Jane>', last: 'Bond' },\n    { first: 'Lars', last: '<Croft>' },\n];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><Jane></td></tr>\n//   <tr><td>Bond</td></tr>\n//\n//   <tr><td>Lars</td></tr>\n//   <tr><td><Croft></td></tr>\n//\n// </table>\n")])])]),n("br"),t._v("\n如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。\n"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 写法一\nlet str = 'return ' + '`Hello ${name}!`';\nlet func = new Function('name', str);\nfunc('Jack') // \"Hello Jack!\"\n\n// 写法二\nlet str = '(name) => `Hello ${name}!`';\nlet func = eval.call(null, str);\nfunc('Jack') // \"Hello Jack!\"\n")])])]),n("h2",{attrs:{id:"_11-实例-模板编译"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11-实例-模板编译"}},[t._v("#")]),t._v(" 11. 实例：模板编译")]),t._v(" "),n("p",[t._v("下面，我们来看一个通过模板字符串，生成生产模板的实例。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let template = `\n<ul>\n  <% for(let i=0; i < data.supplies.length; i++) { %>\n    <li><%= data.supplies[i] %></li>\n  <% } %>\n</ul>\n`;\n")])])]),n("p",[t._v("上面代码在模板字符串之中，放置了一个常规模板。该模板使用 "),n("strong",[t._v("<%...%>")]),t._v(" 放置JavaScript代码，使用 "),n("strong",[t._v("<%=...%>")]),t._v(" 输出 JavaScript 表达式。")]),t._v(" "),n("p",[t._v("怎么编译这个模板字符串呢？")]),t._v(" "),n("p",[t._v("一种思路是将其转换为 JavaScript 表达式字符串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("echo('<ul>');\nfor(let i=0; i < data.supplies.length; i++) {\n  echo('<li>');\n  echo(data.supplies[i]);\n  echo('</li>');\n};\necho('</ul>');\n")])])]),n("p",[t._v("这个转换使用正则表达式就行了。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let evalExpr = /<%=(.+?)%>/g;\nlet expr = /<%([\\s\\S]+?)%>/g;\n\ntemplate = template\n  .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\n  .replace(expr, '`); \\n $1 \\n  echo(`');\n\ntemplate = 'echo(`' + template + '`);';\n")])])]),n("p",[t._v("然后，将 "),n("strong",[t._v("template")]),t._v(" 封装在一个函数里面返回，就可以了。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let script =\n`(function parse(data){\n  let output = "";\n\n  function echo(html){\n    output += html;\n  }\n\n  ${ template }\n\n  return output;\n})`;\n\nreturn script;\n')])])]),n("p",[t._v("将上面的内容拼装成一个模板编译函数 "),n("strong",[t._v("compile")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function compile(template){\n  const evalExpr = /<%=(.+?)%>/g;\n  const expr = /<%([\\s\\S]+?)%>/g;\n\n  template = template\n    .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\n    .replace(expr, '`); \\n $1 \\n  echo(`');\n\n  template = 'echo(`' + template + '`);';\n\n  let script =\n  `(function parse(data){\n    let output = \"\";\n\n    function echo(html){\n      output += html;\n    }\n\n    ${ template }\n\n    return output;\n  })`;\n\n  return script;\n}\n")])])]),n("p",[n("strong",[t._v("compile")]),t._v(" 函数的用法如下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let parse = eval(compile(template));\ndiv.innerHTML = parse({ supplies: [ "broom", "mop", "cleaner" ] });\n//   <ul>\n//     <li>broom</li>\n//     <li>mop</li>\n//     <li>cleaner</li>\n//   </ul>\n')])])]),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_12-标签模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_12-标签模板"}},[t._v("#")]),t._v(" 12. 标签模板")]),t._v(" "),n("p",[t._v("模板字符串的功能，不仅仅是上面这些。他可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("alert`123`\n// 等同于\nalert(123)\n")])])]),n("p",[t._v("标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。")]),t._v(" "),n("p",[t._v("但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let a = 5;\nlet b = 10;\n\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n")])])]),n("p",[t._v("上面代码中，模板字符串前面有一个标识名 "),n("strong",[t._v("tag")]),t._v("，它是一个函数。整个表达式的返回值，就是 "),n("strong",[t._v("tag")]),t._v(" 函数处理模板字符串后的返回值。")]),t._v(" "),n("p",[t._v("函数 "),n("strong",[t._v("tag")]),t._v(" 依次会接收到多个参数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function tag(stringArr, value1, value2){\n  // ...\n}\n\n// 等同于\n\nfunction tag(stringArr, ...values){\n  // ...\n}\n")])])]),n("p",[n("strong",[t._v("tag")]),t._v(" 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。")]),t._v(" "),n("p",[n("strong",[t._v("tag")]),t._v(" 函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此__tag__ 会接收到 "),n("strong",[t._v("value1")]),t._v(" 和 __value2__两个参数。")]),t._v(" "),n("p",[t._v("tag函数所有参数的实际值如下。")]),t._v(" "),n("ul",[n("li",[t._v("第一个参数： "),n("strong",[t._v("['Hello', 'world', '']")])]),t._v(" "),n("li",[t._v("第二个参数： 15")]),t._v(" "),n("li",[t._v("第三个参数： 50")])]),t._v(" "),n("p",[t._v("也就是说，tag函数实际上一下面的形式调用。\ntag(['hello', 'world', ''], 15, 50)")]),t._v(" "),n("p",[t._v("我们可以按照需要编写 "),n("strong",[t._v("tag")]),t._v(" 函数的代码。下面是 "),n("strong",[t._v("tag")]),t._v(" 函数的一种写法，以及运行结果。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let a = 5;\nlet b = 10;\n\nfunction tag(s, v1, v2) {\n  console.log(s[0]);\n  console.log(s[1]);\n  console.log(s[2]);\n  console.log(v1);\n  console.log(v2);\n\n  return "OK";\n}\n\ntag`Hello ${ a + b } world ${ a * b}`;\n// "Hello "\n// " world "\n// ""\n// 15\n// 50\n// "OK"\n')])])]),n("p",[t._v("下面是一个更复杂的例子。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let total = 30;\nlet msg = passthru`The total is ${total} (${total*1.05} with tax)`;\n\nfunction passthru(literals) {\n    let result = '';\n    let i = 0;\n    \n    while (i < literals.length) {\n        result += literals[i++];\n        if (i < arguments.length) {\n            result += arguments[i]\n        }\n    }\n    \n    return result\n}\n\nmsg  // \"The total is 30 (31.5 with tax)\"\n")])])]),n("p",[t._v("上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。\n"),n("strong",[t._v("passthru")]),t._v(" 函数采用 rest 参数的写法如下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function passthru(literals, ...values) {\n  let output = "";\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += literals[index] + values[index];\n  }\n\n  output += literals[index]\n  return output;\n}\n')])])]),n("p",[t._v("“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('let message =\n  SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nfunction SaferHTML(templateData) {\n  let s = templateData[0];\n  for (let i = 1; i < arguments.length; i++) {\n    let arg = String(arguments[i]);\n\n    // Escape special characters in the substitution.\n    s += arg.replace(/&/g, "&amp;")\n            .replace(/</g, "&lt;")\n            .replace(/>/g, "&gt;");\n\n    // Don\'t escape special characters in the template.\n    s += templateData[i];\n  }\n  return s;\n}\n')])])]),n("p",[t._v("上面代码中，"),n("strong",[t._v("sender")]),t._v(" 变量往往是用户提供的，经过 "),n("strong",[t._v("SaferHTML")]),t._v(" 函数处理，里面的特殊字符都会被转义。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let sender = '<script>alert('abc')<\/script>';  // 恶意代码\nlet message = SaferHTML`<p>${sender} has send you a message.</p>`;\n\nmessage\n// <p>&lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message.</p>\n")])])]),n("p",[t._v("标签模板的另一个应用，就是多语言转换（国际化处理）。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`\n// "欢迎访问xxx，您是第xxxx位访问者！"\n')])])]),n("p",[t._v("模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 下面的hashTemplate函数\n// 是一个自定义的模板处理函数\nlet libraryHtml = hashTemplate`\n  <ul>\n    #for book in ${myBooks}\n      <li><i>#{book.title}</i> by #{book.author}</li>\n    #end\n  </ul>\n`;\n")])])]),n("p",[t._v("除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("jsx`\n  <div>\n    <input\n      ref='input'\n      onChange='${this.handleChange}'\n      defaultValue='${this.state.value}' />\n      ${this.state.value}\n   </div>\n`\n")])])]),n("p",[t._v("上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到jsx函数的具体实现。")]),t._v(" "),n("p",[t._v("下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("java`\nclass HelloWorldApp {\n  public static void main(String[] args) {\n    System.out.println(“Hello World!”); // Display the string.\n  }\n}\n`\nHelloWorldApp.main();\n")])])]),n("p",[t._v("模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('console.log`123`\n// ["123", raw: Array[1]]\n')])])]),n("p",[t._v("上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。")]),t._v(" "),n("p",[t._v("请看下面的例子。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('tag`First line\\nSecond line`\n\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n  // strings.raw[0] 为 "First line\\\\nSecond line"\n  // 打印输出 "First line\\nSecond line"\n}\n')])])]),n("p",[t._v("上面代码中，"),n("strong",[t._v("tag")]),t._v(" 函数的第一个参数 "),n("strong",[t._v("strings")]),t._v(" ，有一个 "),n("strong",[t._v("raw")]),t._v(" 属性，也指向一个数组。该数组的成员与 "),n("strong",[t._v("strings")]),t._v(" 数组完全一致。比如，"),n("strong",[t._v("strings")]),t._v(" 数组是 "),n("strong",[t._v('["First line\\nSecond line"]')]),t._v("，那么 "),n("strong",[t._v("strings.raw")]),t._v(" 数组就是 "),n("strong",[t._v('["First line\\nSecond line"]')]),t._v("。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，"),n("strong",[t._v("strings.raw")]),t._v(" 数组会将 \\n 视为 \\\\ 和 n 两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。")]),t._v(" "),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_13-string-raw"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_13-string-raw"}},[t._v("#")]),t._v(" 13. String.raw()")]),t._v(" "),n("p",[t._v("ES6 还为原生的 String 对象，提供了一个 "),n("strong",[t._v("raw")]),t._v(" 方法")]),t._v(" "),n("p",[n("strong",[t._v("String.raw")]),t._v(" 方法，往往用来填充模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串， 对应于替换变量后的模板字符串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('String.raw`Hi\\n${2+3}!`;\n// 返回 "Hi\\\\n5!"\n\nString.raw`Hi\\u000A!`;\n// 返回 "Hi\\\\u000A!"\n')])])]),n("p",[t._v("如果原字符串的斜杠已经转义，那么 "),n("strong",[t._v("String.raw")]),t._v(" 会进行再次转义。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('String.raw`Hi\\\\n`\n// 返回 "Hi\\\\\\\\n"\n')])])]),n("p",[n("strong",[t._v("String.raw")]),t._v(" 方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。")]),t._v(" "),n("p",[n("strong",[t._v("String.raw")]),t._v(" 方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有 "),n("strong",[t._v("raw")]),t._v(" 属性的对象，且 "),n("strong",[t._v("raw")]),t._v(" 属性的值应该是一个数组。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("String.raw({ raw: 'test' }, 0, 1, 2);\n// 't0e1s2t'\n\n// 等同于\nString.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);\n")])])]),n("p",[t._v("作为函数，String.raw的代码实现基本如下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("String.raw = function (strings, ...values) {\n  let output = '';\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n")])])]),n("hr"),t._v(" "),n("br"),t._v(" "),n("h2",{attrs:{id:"_14-模板字符串的限制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_14-模板字符串的限制"}},[t._v("#")]),t._v(" 14.模板字符串的限制")]),t._v(" "),n("p",[t._v("前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。")]),t._v(" "),n("p",[t._v("举例来说，标签模板里面可以嵌入 LaTEX 语言。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function latex(strings) {\n  // ...\n}\n\nlet document = latex`\n\\newcommand{\\fun}{\\textbf{Fun!}}  // 正常工作\n\\newcommand{\\unicode}{\\textbf{Unicode!}} // 报错\n\\newcommand{\\xerxes}{\\textbf{King!}} // 报错\n\nBreve over the h goes \\u{h}ere // 报错\n`\n")])])]),n("p",[t._v("上面代码中， 变量 "),n("strong",[t._v("document")]),t._v(" 内嵌的模板字符串，对于LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。")]),t._v(" "),n("p",[t._v("模板字符串会将 "),n("strong",[t._v("\\u00FF")]),t._v(" 和 "),n("strong",[t._v("\\{42}")]),t._v(" 当作 Unicode 字符进行转义，所以 "),n("strong",[t._v("\\unicode")]),t._v(" 解析时报错；而 "),n("strong",[t._v("\\x56")]),t._v(" 会被当作十六进制字符串转义，所以 "),n("strong",[t._v("\\xerxes")]),t._v(" 会报错。也就是说，\\u 和 \\x 在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。")]),t._v(" "),n("p",[t._v("为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 "),n("strong",[t._v("undefined")]),t._v("，而不是报错，并且从 "),n("strong",[t._v("raw")]),t._v(" 属性上面可以得到原始字符串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function tag(strs) {\n  strs[0] === undefined\n  strs.raw[0] === "\\\\unicode and \\\\u{55}";\n}\ntag`\\unicode and \\u{55}`\n')])])]),n("p",[t._v("上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为 "),n("strong",[t._v("undefined")]),t._v("，但是 "),n("strong",[t._v("raw")]),t._v(" 属性依然可以得到原始字符串，因此 "),n("strong",[t._v("tag")]),t._v(" 函数还是可以对原字符串进行处理。")]),t._v(" "),n("p",[t._v("注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let bad = `bad escape sequence: \\unicode`; // 报错\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);