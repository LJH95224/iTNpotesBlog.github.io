(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{546:function(t,e,s){"use strict";s.r(e);var a=s(42),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_5-正则的扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-正则的扩展"}},[t._v("#")]),t._v(" 5. 正则的扩展")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("RegExp 构造函数")]),t._v(" "),s("li",[t._v("字符串的正则方法")]),t._v(" "),s("li",[t._v("u 修饰符")]),t._v(" "),s("li",[t._v("RegExp.prototype.unicode属性")]),t._v(" "),s("li",[t._v("y 修饰符")]),t._v(" "),s("li",[t._v("RegExp.prototype.sticky 属性")]),t._v(" "),s("li",[t._v("RegExp.prototype.flags 属性")]),t._v(" "),s("li",[t._v("s 修饰符： dotAll模式")]),t._v(" "),s("li",[t._v("后行断言")]),t._v(" "),s("li",[t._v("Unicode 属性类")]),t._v(" "),s("li",[t._v("具名组匹配")]),t._v(" "),s("li",[t._v("String.prototype.matchAll")])])]),t._v(" "),s("hr"),t._v(" "),s("br"),t._v(" "),s("h1",{attrs:{id:"_1-regexp-构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-regexp-构造函数"}},[t._v("#")]),t._v(" 1. RegExp 构造函数")]),t._v(" "),s("p",[t._v("在 ES5 中， "),s("strong",[t._v("RegExp")]),t._v(" 构造函数的参数有两种情况。\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var regex = new RegExp('xyz', 'i');\n\nvar regex = /xyz/i\n")])])]),s("p",[t._v("第二种情况是，参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var regrx = new RegExp(/xyz/i)\n\nvar regrx = /xyz/i;\n")])])]),s("p",[t._v("但是， ES5 不允许此时使用第二个参数添加修饰符，否则会报错。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var regex = new RegExp(/xyz/, 'i');\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n")])])]),s("p",[t._v("ES6 改变了这种行为。如果 "),s("strong",[t._v("RegExp")]),t._v(" 构造函数第一个参数是一个正则对象， 那么可以使用第二个参数指定修饰符。而且返回的正则表达式的修饰符，只使用新指定的修饰符。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("new RegExp(/abc/ig, 'i').flags\n// \"i\"\n")])])]),s("p",[t._v("上面代码中，原有正则表达式的修饰符是 "),s("strong",[t._v("ig")]),t._v("， 它会被第二个参数 "),s("strong",[t._v("i")]),t._v(" 覆盖。")]),t._v(" "),s("h1",{attrs:{id:"_2-字符串的正则方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-字符串的正则方法"}},[t._v("#")]),t._v(" 2.字符串的正则方法")]),t._v(" "),s("p",[t._v("字符串对象共有4个方法，可以使用正则表达式： "),s("strong",[t._v("match()")]),t._v("、"),s("strong",[t._v("replace")]),t._v("、"),s("strong",[t._v("search")]),t._v(" 和 "),s("strong",[t._v("split()")]),t._v("。")]),t._v(" "),s("p",[t._v("ES6 将这 4 个方法，在语言内部全部调用 "),s("strong",[t._v("RegExp")]),t._v(" 的实例方法，从而做到所有与正则相关的方法，全部定义在 "),s("strong",[t._v("RegExp")]),t._v(" 对象上。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("String.prototype.match")]),t._v(" 调用 "),s("strong",[t._v("RegExp.prototype[Symbol.match]")])]),t._v(" "),s("li",[s("strong",[t._v("String.prototype.replace")]),t._v(" 调用 "),s("strong",[t._v("RegExp.prototype[Symbol.replace]")])]),t._v(" "),s("li",[s("strong",[t._v("String.prototype.search")]),t._v(" 调用 "),s("strong",[t._v("RegExp.prototype[Symbol.search]")])]),t._v(" "),s("li",[s("strong",[t._v("String.prototype.split")]),t._v(" 调用 "),s("strong",[t._v("RegExp.prototype[Symbol.split]")])])]),t._v(" "),s("h1",{attrs:{id:"_3-u-修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-u-修饰符"}},[t._v("#")]),t._v(" 3. u 修饰符")]),t._v(" "),s("p",[t._v("ES6 对正则表达式添加了 "),s("strong",[t._v("u")]),t._v(' 修饰符， 含义为 "Unicode模式", 用来正确处理大于 '),s("strong",[t._v("\\uFFFF")]),t._v(" 的 Unicode 字符。 也就是说，会正确处理四个字节的 UTF-16 编码")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/^\\uD83D/u.test('\\uD83D\\uDC2A') // false\n/^\\uD83D/.test('\\uD83D\\uDC2A') // true\n")])])]),s("p",[t._v("上面代码中 "),s("strong",[t._v("\\uD83D\\uDC2A")]),t._v(" 是一个四个字节的 UTF-16 编码，代表一个字符。但是 ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为 "),s("strong",[t._v("true")]),t._v("。 加了 "),s("strong",[t._v("u")]),t._v(" 修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为 "),s("strong",[t._v("false")]),t._v("。")]),t._v(" "),s("p",[t._v("一旦加上 "),s("strong",[t._v("u")]),t._v(" 修饰符好，就会修改下面这些正则表达式的行为")]),t._v(" "),s("h2",{attrs:{id:"_1-点字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-点字符"}},[t._v("#")]),t._v(" （1） 点字符")]),t._v(" "),s("p",[t._v("点（"),s("strong",[t._v(".")]),t._v("）字符在正则表达式中，含义是除了换行符意外的任意单个字符。对于码点大于 __0xFFFF__的 Unicode 字符，点字符不能识别，必须加上 "),s("strong",[t._v("u")]),t._v(" 修饰符。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var s = '𠮷';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n")])])]),s("p",[t._v("上面代码表示，如果不添加 "),s("strong",[t._v("u")]),t._v(" 修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。")]),t._v(" "),s("h2",{attrs:{id:"_2-unicode字符表示法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-unicode字符表示法"}},[t._v("#")]),t._v(" （2）Unicode字符表示法")]),t._v(" "),s("p",[t._v("ES6 新增了使用大括号表示 Unicode 字符， 这种表示法在正则表达式中必须加上 "),s("strong",[t._v("u")]),t._v(" 修饰符，才能识别当中的大括号，否则会被解读为量词")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n")])])]),s("p",[t._v("上面代码表示，如果不加 "),s("strong",[t._v("u")]),t._v(" 修饰符，正则表达式无法识别 "),s("strong",[t._v("\\u{61}")]),t._v(" 这种表示法，只会认为这匹配 61 个连续的 "),s("strong",[t._v("u")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"_3-量词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-量词"}},[t._v("#")]),t._v(" （3）量词")]),t._v(" "),s("p",[t._v("使用 "),s("strong",[t._v("u")]),t._v(" 修饰符后，所有量词都会正确识别码点大于 "),s("strong",[t._v("0xFFFF")]),t._v(" 的 Unicode 字符。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n")])])]),s("h2",{attrs:{id:"_4-预定义模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-预定义模式"}},[t._v("#")]),t._v(" （4）预定义模式")]),t._v(" "),s("p",[s("strong",[t._v("u")]),t._v(" 修饰符也影响到预定义模式，能否正确识别码点大于 "),s("strong",[t._v("0xFFFF")]),t._v(" 的 Unicode 字符。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/^\\S$/.test('𠮷') // false\n/^\\S$/u.test('𠮷') // true\n")])])]),s("p",[t._v("上面代码的 "),s("strong",[t._v("\\S")]),t._v(" 是预定义模式，匹配所有非空白字符。只有加了 __u__修饰符，他才能正确匹配码点大于 "),s("strong",[t._v("0xFFFF")]),t._v(" 的 Unicode 字符。")]),t._v(" "),s("p",[t._v("利用这一点，可以写出一个正确返回字符串长度的函数。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function codePointLength(text) {\n  var result = text.match(/[\\s\\S]/gu);\n  return result ? result.length : 0;\n}\n\nvar s = '𠮷𠮷';\n\ns.length // 4\ncodePointLength(s) // 2\n")])])]),s("h2",{attrs:{id:"_5-i修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-i修饰符"}},[t._v("#")]),t._v(" （5） i修饰符")]),t._v(" "),s("p",[t._v("有些 Unicode 字符的编码不同，但是字型很接近，比如， "),s("strong",[t._v("\\u004B")]),t._v(" 与 "),s("strong",[t._v("\\u212A")]),t._v(" 都是大写的 "),s("strong",[t._v("K")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n")])])]),s("p",[t._v("上面代码中，不加 "),s("strong",[t._v("u")]),t._v(" 修饰符，就无法识别非规范的 "),s("strong",[t._v("K")]),t._v(" 字符。")]),t._v(" "),s("h2",{attrs:{id:"_4-regexp-prototype-unicode属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-regexp-prototype-unicode属性"}},[t._v("#")]),t._v(" （4）RegExp.prototype.unicode属性")])])}),[],!1,null,null,null);e.default=_.exports}}]);